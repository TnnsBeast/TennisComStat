---
title: "Fair Point-Win Predictor"
author: "Group F"
format: html
execute:
  warning: false
  message: false
---

This notebook rebuilds the preprocessing and model from `analysis.qmd`, but only uses features available **before** a point is played (no rally or outcome leakage).

```{r setup}
library(tidyverse)
library(janitor)
library(recipes)
library(keras3)
```

## Load and recode raw data

```{r load}
recode_match <- function(df) {
  df <- df |> janitor::clean_names()
  players <- unique(c(df$x1_1_who_won_the_point, df$x1_11_who_lost_the_point))
  players <- players[!is.na(players) & players != ""]
  if (length(players) != 2) return(NULL)
  p1 <- players[1]; p2 <- players[2]
  df %>%
    mutate(
      winner = case_when(
        x1_1_who_won_the_point == p1 ~ "P1",
        x1_1_who_won_the_point == p2 ~ "P2",
        TRUE ~ NA_character_
      ),
      server = case_when(
        x3_1_server == p1 ~ "P1",
        x3_1_server == p2 ~ "P2",
        TRUE ~ NA_character_
      ),
      returner = case_when(
        x4_1_returner == p1 ~ "P1",
        x4_1_returner == p2 ~ "P2",
        TRUE ~ NA_character_
      ),
      winner = factor(winner, levels = c("P1", "P2")),
      server = factor(server, levels = c("P1", "P2")),
      returner = factor(returner, levels = c("P1", "P2"))
    )
}

path <- "Comstat Data"
files <- list.files(path, pattern = "\\.csv$", full.names = TRUE)

raw_data <- files %>%
  map(~ read_csv(.x, show_col_types = FALSE) |> recode_match()) %>%
  discard(is.null) %>%
  bind_rows(.id = "match_id")
```

## Select fair, pre-point features

- Point identifier/target: `match_id`, `winner`
- Pre-point context: server, returner, serve order, intended serve direction
- Score-derived state: set/game/point scores, break/game point flags, tiebreak

```{r features}
parse_score <- function(score_string) {
  if (is.na(score_string) || score_string == "") {
    return(tibble(
      set_number = NA_integer_,
      games_server = NA_integer_,
      games_returner = NA_integer_,
      points_server = NA_integer_,
      points_returner = NA_integer_,
      tiebreak = NA,
      is_break_point = NA,
      is_game_point = NA
    ))
  }
  parts <- str_split(score_string, ";")[[1]] |> trimws()
  set_number <- as.integer(str_extract(parts[1], "\\d+"))
  game_score <- str_split(parts[2], ":")[[1]]
  games_server <- as.integer(game_score[1])
  games_returner <- as.integer(game_score[2])
  point_raw <- parts[3]
  point_clean <- gsub("\\*", "", point_raw)
  pts <- str_split(point_clean, ":")[[1]]
  pts_map <- c("0" = 0, "15" = 1, "30" = 2, "40" = 3, "AD" = 4)
  points_server <- pts_map[pts[1]]
  points_returner <- pts_map[pts[2]]
  tiebreak <- (points_server > 4 | points_returner > 4)
  is_break_point <- (points_returner == 4 && points_server <= 3)
  is_game_point <- (points_server == 4 && points_returner <= 3)
  tibble(
    set_number,
    games_server,
    games_returner,
    points_server,
    points_returner,
    tiebreak,
    is_break_point,
    is_game_point
  )
}

clean_data <- raw_data %>%
  select(
    match_id,
    winner,
    server,
    returner,
    serve_order       = x3_2_serve_order,
    serve_direction   = x3_3_serve_direction,
    score             = x1_03_score,
    game_score_cond   = x1_4_game_score_conditions,
    set_score_cond    = x1_5_set_score_conditions
  ) %>%
  mutate(parsed = map(score, parse_score)) %>%
  unnest(parsed) %>%
  select(-score) %>%
  mutate(
    server_is_p1 = if_else(server == "P1", 1L, 0L),
    games_diff   = games_server - games_returner,    # game momentum
    points_diff  = points_server - points_returner   # point pressure
  )
```

## Train/test split and preprocessing

```{r preprocess}
clean_data <- clean_data %>%
  mutate(
    across(where(is.character), as.factor),
    winner = as.factor(winner)
  )

set.seed(123)
train_matches <- sample(unique(clean_data$match_id), size = 0.8 * n_distinct(clean_data$match_id))
train_df <- filter(clean_data, match_id %in% train_matches)
test_df  <- filter(clean_data, !match_id %in% train_matches)

categorical_vars <- c("server", "returner", "serve_order", "serve_direction", "game_score_cond", "set_score_cond")
numeric_vars <- c(
  "set_number",
  "games_server", "games_returner", "games_diff",
  "points_server", "points_returner", "points_diff",
  "server_is_p1"
)

rec <- recipe(winner ~ ., data = train_df) %>%
  update_role(match_id, new_role = "ID") %>%
  step_unknown(all_nominal_predictors()) %>%
  step_string2factor(all_nominal_predictors()) %>%
  step_impute_median(all_of(numeric_vars)) %>%
  step_normalize(all_of(numeric_vars))

prep_rec <- prep(rec)
train_processed <- bake(prep_rec, train_df)
test_processed  <- bake(prep_rec, test_df)
```

## Build embedding model (fair inputs only)

```{r model}
make_embedding <- function(input_name, levels) {
  input <- layer_input(shape = 1, dtype = "int32", name = input_name)
  embed_dim <- min(50, ceiling(levels / 2))
  embed <- input |>
    layer_embedding(input_dim = levels + 1,
                    output_dim = embed_dim,
                    name = paste0(input_name, "_embed")) |>
    layer_flatten()
  list(input = input, output = embed)
}

embedding_layers <- map(categorical_vars, ~{
  n_levels <- length(levels(train_processed[[.x]]))
  make_embedding(.x, n_levels)
})

numeric_input <- layer_input(shape = length(numeric_vars), name = "numeric_input")
numeric_dense <- numeric_input |>
  layer_dense(units = 32, activation = "relu")

all_inputs <- c(map(embedding_layers, "input"), list(numeric_input))
all_embeddings <- map(embedding_layers, "output")

output <- layer_concatenate(c(all_embeddings, list(numeric_dense))) |>
  layer_dense(units = 128, activation = "relu") |>
  layer_dropout(0.3) |>
  layer_dense(units = 64, activation = "relu") |>
  layer_dropout(0.3) |>
  layer_dense(units = length(levels(train_processed$winner)),
              activation = "softmax",
              name = "output")

model <- keras_model(inputs = all_inputs, outputs = output) |>
  compile(
    loss = "sparse_categorical_crossentropy",
    optimizer = "adam",
    metrics = "accuracy"
  )
```

## Train

```{r train}
x_train <- lapply(categorical_vars, function(col) as.integer(train_processed[[col]]))
names(x_train) <- categorical_vars
x_train[["numeric_input"]] <- as.matrix(train_processed[numeric_vars])
y_train <- as.integer(train_processed$winner) - 1

class_counts <- table(train_processed$winner)
class_weights <- as.list(sum(class_counts) / (length(class_counts) * class_counts))
names(class_weights) <- 0:(length(class_weights) - 1)  # keras expects 0-based names

early_stop <- callback_early_stopping(
  monitor = "val_loss",
  patience = 120,
  restore_best_weights = TRUE
)

history <- model |>
  fit(
    x = x_train,
    y = y_train,
    epochs = 120,
    batch_size = 64,
    validation_split = 0.2,
    callbacks = list(early_stop),
    class_weight = class_weights
  )
```

```{r metrics, echo=FALSE, fig.width=7, fig.height=8}
acc      <- history$metrics$accuracy
val_acc  <- history$metrics$val_accuracy
loss     <- history$metrics$loss
val_loss <- history$metrics$val_loss
epochs   <- seq_along(acc)

df_plot <- tibble(
  epoch = epochs,
  accuracy = acc,
  val_accuracy = val_acc,
  loss = loss,
  val_loss = val_loss
)

ggplot(df_plot, aes(x = epoch)) +
  geom_line(aes(y = accuracy, color = "Training Accuracy"), linewidth = 1) +
  geom_line(aes(y = val_accuracy, color = "Validation Accuracy"), linewidth = 1) +
  labs(title = "Accuracy Over Epochs", x = "Epoch", y = "Accuracy", color = "") +
  scale_color_manual(values = c("Training Accuracy" = "blue", "Validation Accuracy" = "red")) +
  theme_minimal(base_size = 14)
```

## Evaluate on held-out matches

```{r evaluate}
x_test <- lapply(categorical_vars, function(col) as.integer(test_processed[[col]]))
names(x_test) <- categorical_vars
x_test[["numeric_input"]] <- as.matrix(test_processed[numeric_vars])
y_test <- as.integer(test_processed$winner) - 1

model |> evaluate(x_test, y_test)
```

This model uses only pre-point context, avoiding leakage from rally outcomes or post-serve events.
